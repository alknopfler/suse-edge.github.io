"use strict";(self.webpackChunksuse_edge_docs=self.webpackChunksuse_edge_docs||[]).push([[5134],{3609:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var t=i(5893),s=i(1151);const a={title:"Using NVIDIA GPU's on SLE Micro"},o="Intro",r={id:"integrations/nvidia-slemicro",title:"Using NVIDIA GPU's on SLE Micro",description:"In this guide, we'll show you how to implement host-level NVIDIA GPU support via the pre-built open-source drivers on SLE Micro 5.3+. In other words, drivers that are baked into the operating system rather than dynamically loaded by NVIDIA's GPU Operator. This configuration is highly desirable for customers that want to pre-bake all artefacts required for deployment into the image, and where the dynamic selection of the driver version, i.e. the user is selecting the version of the driver via Kubernetes, is not a requirement. This guide initially explains how to deploy the additional components onto a system that has already been pre-deployed, but follows with a section that describes how to embed this configuration into the initial deployment via Edge Image Builder. If you do not want to run through the basics and standing things up manually, skip right ahead to that section.",source:"@site/docs/integrations/nvidia-slemicro.md",sourceDirName:"integrations",slug:"/integrations/nvidia-slemicro",permalink:"/docs/integrations/nvidia-slemicro",draft:!1,unlisted:!1,editUrl:"https://github.com/suse-edge/suse-edge.github.io/tree/main/docs/integrations/nvidia-slemicro.md",tags:[],version:"current",lastUpdatedBy:"Rhys Oxenham",lastUpdatedAt:1709239351,formattedLastUpdatedAt:"Feb 29, 2024",frontMatter:{title:"Using NVIDIA GPU's on SLE Micro"},sidebar:"docs",previous:{title:"Setting up NATS on K3s",permalink:"/docs/integrations/nats"},next:{title:"Create a simple container image based on Tumbleweed using OBS (openSUSE Build Service)",permalink:"/docs/misc/create-a-simple-container-image-obs"}},l={},d=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Manual Installation",id:"manual-installation",level:2},{value:"Further Validation of the Manual Installation",id:"further-validation-of-the-manual-installation",level:2},{value:"Implementation with Kubernetes",id:"implementation-with-kubernetes",level:2},{value:"Bringing it together via Edge Image Builder",id:"bringing-it-together-via-edge-image-builder",level:2},{value:"Resolving issues",id:"resolving-issues",level:2},{value:"nvidia-smi does not find the GPU",id:"nvidia-smi-does-not-find-the-gpu",level:3}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"intro",children:"Intro"}),"\n",(0,t.jsxs)(n.p,{children:["In this guide, we'll show you how to implement host-level NVIDIA GPU support via the pre-built ",(0,t.jsx)(n.a,{href:"https://github.com/NVIDIA/open-gpu-kernel-modules",children:"open-source drivers"})," on SLE Micro 5.3+. In other words, drivers that are baked into the operating system rather than dynamically loaded by NVIDIA's ",(0,t.jsx)(n.a,{href:"https://github.com/NVIDIA/gpu-operator",children:"GPU Operator"}),". This configuration is highly desirable for customers that want to pre-bake all artefacts required for deployment into the image, and where the dynamic selection of the driver version, i.e. the user is selecting the version of the driver via Kubernetes, is not a requirement. This guide initially explains how to deploy the additional components onto a system that has already been pre-deployed, but follows with a section that describes how to embed this configuration into the initial deployment via Edge Image Builder. If you do not want to run through the basics and standing things up manually, skip right ahead to that section."]}),"\n",(0,t.jsxs)(n.p,{children:["It's important to call out that the support for these drivers is provided by both SUSE and NVIDIA in tight collaboration, where the driver is built and shipped by SUSE as part of the package repositories, however if you have any concerns or questions about the combination in which you're utilising the drivers, then please ask your SUSE or NVIDIA account managers for further assistance. If you're planning on utilising ",(0,t.jsx)(n.a,{href:"https://www.nvidia.com/en-gb/data-center/products/ai-enterprise/",children:"NVIDIA AI Enterprise"})," (NVAIE) you will need to ensure that you're using an ",(0,t.jsx)(n.a,{href:"https://docs.nvidia.com/datacenter/cloud-native/gpu-operator/latest/platform-support.html#supported-nvidia-gpus-and-systems",children:"NVAIE certified GPU"}),", which ",(0,t.jsx)(n.em,{children:"may"})," require the use of proprietary NVIDIA drivers. If you're unsure, please speak with your NVIDIA representative."]}),"\n",(0,t.jsxs)(n.p,{children:["Further information about NVIDIA GPU operator integration is ",(0,t.jsx)(n.em,{children:"not"})," covered in this guide, however should you want to utilise the GPU Operator for Kubernetes integration, it should still be possible to follow much of the steps in this guide to setup the underlying operating system and simply enabling the GPU operator to utilise the ",(0,t.jsx)(n.em,{children:"pre-installed"})," drivers via the ",(0,t.jsx)(n.code,{children:"driver.enabled=false"})," flag in the NVIDIA GPU Operator Helm chart, where it will simply pick-up the already installed drivers on the host; more comprehensive instructions are available from NVIDIA ",(0,t.jsx)(n.a,{href:"https://docs.nvidia.com/datacenter/cloud-native/gpu-operator/latest/install-gpu-operator.html#chart-customization-options",children:"here"}),". SUSE recently also made a ",(0,t.jsx)(n.a,{href:"https://documentation.suse.com/trd/kubernetes/single-html/gs_rke2-slebci_nvidia-gpu-operator/",children:"Technical Reference Documentation"})," (TRD) available that discusses how to utilise the GPU operator and the NVIDIA proprietary drivers, should this be a requirement for your use-case."]}),"\n",(0,t.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsx)(n.p,{children:"If you're following this guide, it's assumed that you've got the following already available:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"At least one host with SLE Micro 5.3+ installed; this can be physical or virtual."}),"\n",(0,t.jsxs)(n.li,{children:["Your host(s) is/are attached to a subscription as this will be required for package access - an evaluation is available ",(0,t.jsx)(n.a,{href:"https://www.suse.com/download/sle-micro/",children:"here"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.a,{href:"https://github.com/NVIDIA/open-gpu-kernel-modules#compatible-gpus",children:"compatible NVIDIA GPU"})," installed (or ",(0,t.jsx)(n.em,{children:"fully"})," passed through to the virtual machine in which SLE Micro is running)."]}),"\n",(0,t.jsxs)(n.li,{children:["Access to the root user - these instructions assume you're the root user, and ",(0,t.jsx)(n.em,{children:"not"})," escalating your privileges via ",(0,t.jsx)(n.code,{children:"sudo"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"manual-installation",children:"Manual Installation"}),"\n",(0,t.jsxs)(n.p,{children:["In this section you're going to install the NVIDIA drivers directly onto the SLE Micro operating system as the NVIDIA open-driver is now part of the core SLE Micro package repositories, which makes it as easy as installing the required RPM packages; there is no compilation or downloading of executable packages required. Below we're going to walk through the deployment of the \"G06\" generation of driver, which supports the latest GPU's (please see ",(0,t.jsx)(n.a,{href:"https://en.opensuse.org/SDB:NVIDIA_drivers#Install",children:"here"})," for further information), so please ensure that you're selecting an appropriate driver generation for the NVIDIA GPU that your system has. If it's a modern GPU, it's highly likely that \"G06\" will be the correct driver."]}),"\n",(0,t.jsxs)(n.p,{children:["Before we begin, it's important to recognise that in addition to the NVIDIA open-driver that SUSE ship as part of SLE Micro, it's more than likely that to support the installation you're going to want to install additional NVIDIA components, for example, OpenGL libraries, CUDA toolkits, command-line utilities such as ",(0,t.jsx)(n.code,{children:"nvidia-smi"}),", and container-integration components such as the ",(0,t.jsx)(n.code,{children:"nvidia-container-toolkit"}),". Many of these components are not shipped by SUSE as they're either proprietary NVIDIA software, or it makes no sense for us to ship them instead of NVIDIA. Therefore, as part of the instructions we're going to be configuring some additional repositories that give us access to said components, and we'll walk through some examples of how to leverage some of these tools, resulting in a fully-functional system. It's important to make this distiction between SUSE repositories and NVIDIA repositories, as occasionally there can be a mismatch between the package versions that NVIDIA make available versus what SUSE has built, this usually arrises when SUSE make a new version of the open-driver available, and there's a couple of days before the equivalent packages are made available in NVIDIA repositories to match."]}),"\n",(0,t.jsxs)(n.p,{children:["Therefore, what's advised is that you not only ensure that the driver version that you're selecting is compatible with your GPU, and meets any CUDA requirements that you may have by checking the ",(0,t.jsx)(n.a,{href:"https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/",children:"CUDA release notes"}),", that the driver version that you plan on deploying also has a matching version in the ",(0,t.jsx)(n.a,{href:"http://download.nvidia.com/suse/sle15sp5/x86_64/",children:"NVIDIA SLE15-SP5 repository"})," to ensure that you will have equivalent package versions for the supporting components available. The easiest way to check the available versions of the NVIDIA open-driver is to search on SUSE Customer Centre by looking at all of the packages available in ",(0,t.jsx)(n.a,{href:"https://scc.suse.com/packages?name=SUSE%20Linux%20Enterprise%20Micro&version=5.5&arch=x86_64",children:"SLE Micro 5.5 for x86_64"}),' and searching for the "nvidia-open-driver", here you\'ll see that there are ',(0,t.jsx)(n.em,{children:"four"})," versions available, with ",(0,t.jsx)(n.em,{children:"545.29.06"})," being the newest:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"SUSE Customer Centre",src:i(4319).Z+"",width:"2792",height:"1426"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["NOTE: The same could have been achieved on the target machine by executing ",(0,t.jsx)(n.code,{children:"zypper se -s nvidia-open-driver"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["When you've confirmed that an equivalent version is available in the NVIDIA repos, you're ready to install the packages on the host operating system, and for this we need to open up a ",(0,t.jsx)(n.code,{children:"transactional-update"})," session, which creates a new read/write snapshot of the underlying operating system so we can make changes to the immutable platform (for further instructions on ",(0,t.jsx)(n.code,{children:"transactional-update"})," see ",(0,t.jsx)(n.a,{href:"https://documentation.suse.com/sle-micro/5.4/html/SLE-Micro-all/sec-transactional-udate.html",children:"here"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"transactional-update shell\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When you're in your ",(0,t.jsx)(n.code,{children:"transactional-update"})," shell, add an additional package repository from NVIDIA; this will allow us to pull in additional utilities, e.g. ",(0,t.jsx)(n.code,{children:"nvidia-smi"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"zypper ar https://download.nvidia.com/suse/sle15sp5/ nvidia-sle15sp5-main\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can then install the driver and the ",(0,t.jsx)(n.code,{children:"nvidia-compute-utils"})," for additional utilities, note that if you don't need the utils you can omit it, but for testing purposes it's worth installing at this stage:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"zypper install -y nvidia-open-driver-G06-signed-kmp nvidia-compute-utils-G06\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["NOTE: If this fails to install it's likely that there's a dependency mismatch between the selected driver version and what NVIDIA is shipping in their repositories - please revisit the section above to validate that your versions match. You may want to attempt to install a different driver version, for example, if the NVIDIA repositories have an earlier version, you can try specifying ",(0,t.jsx)(n.code,{children:"nvidia-open-driver-G06-signed-kmp=545.29.06"})," on your install command to specify a version that aligns."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Next, if you're ",(0,t.jsx)(n.em,{children:"not"})," using a supported GPU, remembering that the list can be found ",(0,t.jsx)(n.a,{href:"https://github.com/NVIDIA/open-gpu-kernel-modules#compatible-gpus",children:"here"}),", you can see if the driver will work by enabling support at the module level, but your mileage may vary -- skip this step if you're using a ",(0,t.jsx)(n.em,{children:"supported"})," GPU:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"sed -i '/NVreg_OpenRmEnableUnsupportedGpus/s/^#//g' /etc/modprobe.d/50-nvidia-default.conf\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now that you've installed these packages, it's time to exit the ",(0,t.jsx)(n.code,{children:"transactional-update"})," session:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"exit\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["NOTE: Please make sure that you've exited the ",(0,t.jsx)(n.code,{children:"transactional-update"})," session before proceeding!"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Now that you've got your drivers installed, it's time to reboot, as SLE Micro is an immutable operating system it needs to reboot into the new snapshot that you created in a previous step; the drivers are only installed into this new snapshot, and hence it's not possible to load the drivers without rebooting into this new snapshot, which will happen automatically. Issue the reboot command when you're ready:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"reboot\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Once the system has rebooted successfully, log back in and try to use the ",(0,t.jsx)(n.code,{children:"nvidia-smi"})," tool to verify that the driver is loaded successfully and that it's able to both access and enumerate your GPU(s):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"nvidia-smi\n"})}),"\n",(0,t.jsx)(n.p,{children:"The output of this command should show you something similar to the following output, noting that in the example below we have two GPU's:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"Wed Feb 28 12:31:06 2024\n+---------------------------------------------------------------------------------------+\n| NVIDIA-SMI 545.29.06              Driver Version: 545.29.06    CUDA Version: 12.3     |\n|-----------------------------------------+----------------------+----------------------+\n| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |\n|                                         |                      |               MIG M. |\n|=========================================+======================+======================|\n|   0  NVIDIA A100-PCIE-40GB          Off | 00000000:17:00.0 Off |                    0 |\n| N/A   29C    P0              35W / 250W |      4MiB / 40960MiB |      0%      Default |\n|                                         |                      |             Disabled |\n+-----------------------------------------+----------------------+----------------------+\n|   1  NVIDIA A100-PCIE-40GB          Off | 00000000:CA:00.0 Off |                    0 |\n| N/A   30C    P0              33W / 250W |      4MiB / 40960MiB |      0%      Default |\n|                                         |                      |             Disabled |\n+-----------------------------------------+----------------------+----------------------+\n\n+---------------------------------------------------------------------------------------+\n| Processes:                                                                            |\n|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |\n|        ID   ID                                                             Usage      |\n|=======================================================================================|\n|  No running processes found                                                           |\n+---------------------------------------------------------------------------------------+\n"})}),"\n",(0,t.jsx)(n.p,{children:"...and that's it! You've successfully installed and verified that the NVIDIA drivers are loaded into SLE Micro."}),"\n",(0,t.jsx)(n.h2,{id:"further-validation-of-the-manual-installation",children:"Further Validation of the Manual Installation"}),"\n",(0,t.jsxs)(n.p,{children:["At this stage, all we've been able to verify is that at the host level the NVIDIA device can be accessed and that the drivers are loading successfully. However, if we want to be sure that it's functioning, a simple test would be to try and validate that the GPU can take instruction from a user-space application, ideally via a container, and through the CUDA library, as that's typically what a real workload would utilise. For this, we can make a further modification to the host OS by installing the ",(0,t.jsx)(n.code,{children:"nvidia-container-toolkit"})," (",(0,t.jsx)(n.a,{href:"https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html#installing-with-zypper",children:"NVIDIA Container Toolkit"}),"). First, open up another ",(0,t.jsx)(n.code,{children:"transactional-update"})," shell, noting that we could have done this in a single transaction in the previous step, and we'll show how to do this fully automated in a later section:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"transactional-update shell\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Next, install the ",(0,t.jsx)(n.code,{children:"nvidia-container-toolkit"})," package from the NVIDIA CUDA repo:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"zypper ar https://nvidia.github.io/libnvidia-container/stable/rpm/nvidia-container-toolkit.repo nvidia-container-toolkit\nzypper zypper --gpg-auto-import-keys install -y nvidia-container-toolkit\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When you're ready, you can exit the ",(0,t.jsx)(n.code,{children:"transactional-update"})," shell:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"exit\n"})}),"\n",(0,t.jsx)(n.p,{children:"...and reboot the machine into the new snapshot:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"reboot\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["NOTE: As before, you will need to ensure that you've exited the ",(0,t.jsx)(n.code,{children:"transactional-shell"})," and rebooted the machine for your changes to be enacted."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Now that the machine has rebooted, you can validate that the system is able to successfully enumerate the devices via the NVIDIA Container Toolkit (the output should be verbose, and it should provide a number of INFO and WARN messages, but no ERROR messages):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This will ensure that any container started on the machine can leverage NVIDIA GPU devices that have been discovered. When ready, you can then run a podman-based container (doing this via ",(0,t.jsx)(n.code,{children:"podman"})," gives us a good way of validating access to the NVIDIA device from within a container, which should give confidence for doing the same with Kubernetes at a later stage), giving it access to the labelled NVIDIA device(s) that were taken care of by the previous command, based on ",(0,t.jsx)(n.a,{href:"https://registry.suse.com/bci/bci-base-15sp5/index.html",children:"SLE BCI"})," and simply running bash:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"podman run --rm --device nvidia.com/gpu=all --security-opt=label=disable -it registry.suse.com/bci/bci-base:latest bash\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You will now be executing commands from within a temporary podman container; it doesn't have any access to your underlying system and is ephemeral in nature so whatever we do here will not persist and you shouldn't be able to break anything on the underlying host. As we're now in a container, we can install the required CUDA libraries, again checking the correct CUDA version for your driver ",(0,t.jsx)(n.a,{href:"https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/",children:"here"})," although the previous output of ",(0,t.jsx)(n.code,{children:"nvidia-smi"})," should show the required CUDA version. In the example below we're installing ",(0,t.jsx)(n.em,{children:"CUDA 12.3"})," and we're pulling a large number of examples, demo's, and development kits so you can fully validate the GPU:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"zypper ar http://developer.download.nvidia.com/compute/cuda/repos/sles15/x86_64/ cuda-sle15-sp5\nzypper in -y cuda-libraries-devel-12-3 cuda-minimal-build-12-3 cuda-demo-suite-12-3\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Once this has been installed successfully, don't exit from the container, we'll run the ",(0,t.jsx)(n.code,{children:"deviceQuery"})," CUDA example, which will comprehensively validate GPU access via CUDA, and from within the container itself:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"/usr/local/cuda-12/extras/demo_suite/deviceQuery\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If successful, you should see output that shows similar to the following, noting the ",(0,t.jsx)(n.code,{children:"Result = PASS"})," message at the end of the command, noting that in the output below my system is correctly identifying two GPU's, whereas your environment may only have one:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:'/usr/local/cuda-12/extras/demo_suite/deviceQuery Starting...\n\n CUDA Device Query (Runtime API) version (CUDART static linking)\n\nDetected 2 CUDA Capable device(s)\n\nDevice 0: "NVIDIA A100-PCIE-40GB"\n  CUDA Driver Version / Runtime Version          12.2 / 12.1\n  CUDA Capability Major/Minor version number:    8.0\n  Total amount of global memory:                 40339 MBytes (42298834944 bytes)\n  (108) Multiprocessors, ( 64) CUDA Cores/MP:     6912 CUDA Cores\n  GPU Max Clock rate:                            1410 MHz (1.41 GHz)\n  Memory Clock rate:                             1215 Mhz\n  Memory Bus Width:                              5120-bit\n  L2 Cache Size:                                 41943040 bytes\n  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)\n  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers\n  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers\n  Total amount of constant memory:               65536 bytes\n  Total amount of shared memory per block:       49152 bytes\n  Total number of registers available per block: 65536\n  Warp size:                                     32\n  Maximum number of threads per multiprocessor:  2048\n  Maximum number of threads per block:           1024\n  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)\n  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)\n  Maximum memory pitch:                          2147483647 bytes\n  Texture alignment:                             512 bytes\n  Concurrent copy and kernel execution:          Yes with 3 copy engine(s)\n  Run time limit on kernels:                     No\n  Integrated GPU sharing Host Memory:            No\n  Support host page-locked memory mapping:       Yes\n  Alignment requirement for Surfaces:            Yes\n  Device has ECC support:                        Enabled\n  Device supports Unified Addressing (UVA):      Yes\n  Device supports Compute Preemption:            Yes\n  Supports Cooperative Kernel Launch:            Yes\n  Supports MultiDevice Co-op Kernel Launch:      Yes\n  Device PCI Domain ID / Bus ID / location ID:   0 / 23 / 0\n  Compute Mode:\n     < Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) >\n\nDevice 1: <snip to reduce output for multiple devices>\n     < Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) >\n> Peer access from NVIDIA A100-PCIE-40GB (GPU0) -> NVIDIA A100-PCIE-40GB (GPU1) : Yes\n> Peer access from NVIDIA A100-PCIE-40GB (GPU1) -> NVIDIA A100-PCIE-40GB (GPU0) : Yes\n\ndeviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 12.3, CUDA Runtime Version = 12.3, NumDevs = 2, Device0 = NVIDIA A100-PCIE-40GB, Device1 = NVIDIA A100-PCIE-40GB\nResult = PASS\n'})}),"\n",(0,t.jsx)(n.p,{children:"From here, you can continue to run any other CUDA workload - you can utilise compilers, and any other aspect of the CUDA ecosystem to run some further tests. When you're done you can exit from the container, noting that whatever you've installed in there is ephemeral (so will be lost!), and hasn't impacted the underlying operating system:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"exit\n"})}),"\n",(0,t.jsx)(n.h2,{id:"implementation-with-kubernetes",children:"Implementation with Kubernetes"}),"\n",(0,t.jsxs)(n.p,{children:["Now that we've proven the installation and utilisation of the NVIDIA open-driver on SLE Micro, let's explore how you would configure Kubernetes on the same machine to do the same. This guide will not walk you through the deployment of Kubernetes, but it's assumed that you've either installed ",(0,t.jsx)(n.a,{href:"https://k3s.io/",children:"k3s"})," or ",(0,t.jsx)(n.a,{href:"https://docs.rke2.io/install/quickstart",children:"RKE2"})," and that you've got your kubeconfig configured accordingly so that standard ",(0,t.jsx)(n.code,{children:"kubectl"})," commands can be executed as the superuser. We assume that your node forms a single-node cluster, although there's no reason why the instructions would differ considerably for multi-node clusters. Firstly, ensure that your ",(0,t.jsx)(n.code,{children:"kubectl"})," access is working:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"kubectl get nodes\n"})}),"\n",(0,t.jsx)(n.p,{children:"This should show something similar to the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"NAME       STATUS   ROLES                       AGE   VERSION\nnode0001   Ready    control-plane,etcd,master   13d   v1.28.6+rke2r1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["What you should find is that your k3s/rke2 installation has detected the presence of the NVIDIA Container Toolkit on the host and automatically configured the NVIDIA runtime integration into ",(0,t.jsx)(n.code,{children:"containerd"})," (the Container Runtime Interface that k3s/rke2 utilise); this can be confirmed by looking at the containerd ",(0,t.jsx)(n.code,{children:"config.toml"})," file:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"tail -n8 /var/lib/rancher/rke2/agent/etc/containerd/config.toml\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Which should show something akin to the following, note that the equivalent k3s location is ",(0,t.jsx)(n.code,{children:"/var/lib/rancher/k3s/agent/etc/containerd/config.toml"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:'[plugins."io.containerd.grpc.v1.cri".containerd.runtimes."nvidia"]\n  runtime_type = "io.containerd.runc.v2"\n[plugins."io.containerd.grpc.v1.cri".containerd.runtimes."nvidia".options]\n  BinaryName = "/usr/bin/nvidia-container-runtime"\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"NOTE: If these entries are not present, the detection has failed and it's likely that you haven't restarted the machine, or the Kubernetes services. You can add these in manually as above, if required."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Next, we need to configure the NVIDIA ",(0,t.jsx)(n.code,{children:"RuntimeClass"})," as an additional Kubernetes runtime to the default, ensuring that any user requests for pods that need access to the GPU can leverage the NVIDIA Container Toolkit to do so, via the ",(0,t.jsx)(n.code,{children:"nvidia-container-runtime"}),", as configured in the ",(0,t.jsx)(n.code,{children:"containerd"})," configuration:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"kubectl apply -f - <<EOF\napiVersion: node.k8s.io/v1\nkind: RuntimeClass\nmetadata:\n  name: nvidia\nhandler: nvidia\nEOF\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The next step is to configure the ",(0,t.jsx)(n.a,{href:"https://github.com/NVIDIA/k8s-device-plugin",children:"NVIDIA Device Plugin"})," which configures Kubernetes to be able to leverage the NVIDIA GPU's as resources within the cluster that can be utilised, working in combination with the NVIDIA Container Toolkit. This tool will initially detect all capabilities on the underlying host in terms of GPU's, drivers, and other capabilities (e.g. GL) and will then allow you to request GPU resources, and consume them as part of your applications."]}),"\n",(0,t.jsx)(n.p,{children:"First you'll need to add and update the Helm repository for the NVIDIA Device Plugin:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"helm repo add nvdp https://nvidia.github.io/k8s-device-plugin\nhelm repo update\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now you can install the NVIDIA Device Plugin:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"helm upgrade -i nvdp nvdp/nvidia-device-plugin --namespace nvidia-device-plugin --create-namespace --version 0.14.5 --set runtimeClassName=nvidia\n"})}),"\n",(0,t.jsx)(n.p,{children:"After a few minutes, you should see that there's a new pod running that will complete the detection on your available node(s) and will tag them with the number of GPU's that have been detected:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:'kubectl get pods -n nvidia-device-plugin\nNAME                              READY   STATUS    RESTARTS      AGE\nnvdp-nvidia-device-plugin-jp697   1/1     Running   2 (12h ago)   6d3h\n\nkubectl get node node0001 -o json | jq .status.capacity\n{\n  "cpu": "128",\n  "ephemeral-storage": "466889732Ki",\n  "hugepages-1Gi": "0",\n  "hugepages-2Mi": "0",\n  "memory": "32545636Ki",\n  "nvidia.com/gpu": "1",                      <----\n  "pods": "110"\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now you're ready to create an NVIDIA pod that attempts to utilise this GPU, let's try with the CUDA Benchmark container:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:'kubectl apply -f - <<EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nbody-gpu-benchmark\n  namespace: default\nspec:\n  restartPolicy: OnFailure\n  runtimeClassName: nvidia\n  containers:\n  - name: cuda-container\n    image: nvcr.io/nvidia/k8s/cuda-sample:nbody\n    args: ["nbody", "-gpu", "-benchmark"]\n    resources:\n      limits:\n        nvidia.com/gpu: 1\n    env:\n    - name: NVIDIA_VISIBLE_DEVICES\n      value: all\n    - name: NVIDIA_DRIVER_CAPABILITIES\n      value: all\nEOF\n'})}),"\n",(0,t.jsx)(n.p,{children:"If all went well, you should be able to look at the logs and see the benchmark information:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:'kubectl logs nbody-gpu-benchmark\nRun "nbody -benchmark [-numbodies=<numBodies>]" to measure performance.\n\t-fullscreen       (run n-body simulation in fullscreen mode)\n\t-fp64             (use double precision floating point values for simulation)\n\t-hostmem          (stores simulation data in host memory)\n\t-benchmark        (run benchmark to measure performance)\n\t-numbodies=<N>    (number of bodies (>= 1) to run in simulation)\n\t-device=<d>       (where d=0,1,2.... for the CUDA device to use)\n\t-numdevices=<i>   (where i=(number of CUDA devices > 0) to use for simulation)\n\t-compare          (compares simulation results running once on the default GPU and once on the CPU)\n\t-cpu              (run n-body simulation on the CPU)\n\t-tipsy=<file.bin> (load a tipsy model file for simulation)\n\nNOTE: The CUDA Samples are not meant for performance measurements. Results may vary when GPU Boost is enabled.\n\n> Windowed mode\n> Simulation data stored in video memory\n> Single precision floating point simulation\n> 1 Devices used for simulation\nGPU Device 0: "Turing" with compute capability 7.5\n\n> Compute 7.5 CUDA device: [Tesla T4]\n40960 bodies, total time for 10 iterations: 101.677 ms\n= 165.005 billion interactions per second\n= 3300.103 single-precision GFLOP/s at 20 flops per interaction\n'})}),"\n",(0,t.jsx)(n.p,{children:"Finally, if your applications require OpenGL, you can install the required NVIDIA OpenGL libraries at the host-level and the NVIDIA Device Plugin and NVIDIA Container Toolkit can make them available to containers, for this you'll need to install the package as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"transactional-update pkg install nvidia-gl-G06\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"NOTE: You will need to reboot to make this package available to your applications; the NVIDIA Device Plugin should automatically redetect this via the NVIDIA Container Toolkit."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"bringing-it-together-via-edge-image-builder",children:"Bringing it together via Edge Image Builder"}),"\n",(0,t.jsxs)(n.p,{children:["Okay, so you've demonstrated full functionality of your applications and GPU's on SLE Micro and you now want to utilise ",(0,t.jsx)(n.a,{href:"https://github.com/suse-edge/edge-image-builder",children:"SUSE Edge Image Builder"})," to provision it all together via a deployable/consumable ISO or RAW disk image. This guide doesn't explain how to use Edge Image Buillder but it does provide the necessary configurations to be able to achieve such a configuration. Below you will find an example of an image definition, along with the necessary Kubernetes configuration files to ensure that all of the required components are deployed out of the box. Here's the directory structure of the Edge Image Builder directory for the example shown below:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:".\n\u251c\u2500\u2500 base-images\n\u2502\xa0\xa0 \u251c\u2500\u2500 SLE-Micro.x86_64-5.5.0-Default-SelfInstall-GM.install.iso\n\u251c\u2500\u2500 eib-config-iso.yaml\n\u251c\u2500\u2500 kubernetes\n\u2502\xa0\xa0 \u251c\u2500\u2500 config\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 server.yaml\n\u2502\xa0\xa0 \u251c\u2500\u2500 helm\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 nvidia-device-plugin.yaml\n\u2502\xa0\xa0 \u2514\u2500\u2500 manifests\n\u2502\xa0\xa0     \u2514\u2500\u2500 nvidia-runtime-class.yaml\n\u251c\u2500\u2500 rpms\n\u2502\xa0\xa0 \u251c\u2500\u2500 gpg-keys\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 nvidia-container-toolkit.key\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Let's explore those files, firstly, here's a sample image definition for a single-node cluster running k3s that deploys the utils and OpenGL packages too (",(0,t.jsx)(n.code,{children:"eib-config-iso.yaml"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: 1.0\nimage:\n  arch: x86_64\n  imageType: iso\n  baseImage: SLE-Micro.x86_64-5.5.0-Default-SelfInstall-GM.install.iso\n  outputImageName: deployimage.iso\noperatingSystem:\n  time:\n    timezone: Europe/London\n    ntp:\n      pools:\n        - 2.suse.pool.ntp.org\n  isoConfiguration:\n    installDevice: /dev/sda\n    unattended: true\n  users:\n    - username: root\n      encryptedPassword: $6$XcQN1xkuQKjWEtQG$WbhV80rbveDLJDz1c93K5Ga9JDjt3mF.ZUnhYtsS7uE52FR8mmT8Cnii/JPeFk9jzQO6eapESYZesZHO9EslD1\n  packages:\n    packageList:\n      - nvidia-open-driver-G06-signed-kmp-default\n      - nvidia-compute-utils-G06\n      - nvidia-gl-G06\n      - nvidia-container-toolkit\n    additionalRepos:\n      - url: https://download.nvidia.com/suse/sle15sp5/\n      - url: https://nvidia.github.io/libnvidia-container/stable/rpm/nvidia-container-toolkit.repo\n    sccRegistrationCode: <snip>\nkubernetes:\n  version: v1.28.6+k3s1\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["NOTE: This is just an example, you will need to modify to fit your requirements and expectations and you will need to provide your own ",(0,t.jsx)(n.code,{children:"sccRegistrationCode"})," here if using SLE Micro to resolve package dependencies and pull the NVIDIA drivers."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In addition to this, we need to add some additional components so they get loaded by Kubernetes at boot time. The EIB directory needs a ",(0,t.jsx)(n.code,{children:"kubernetes"})," directory first with some sub-directories for the configuration, helm charts, and any additional manifests required:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"mkdir -p kubernetes/config kubernetes/helm kubernetes/manifests\n"})}),"\n",(0,t.jsx)(n.p,{children:"Let's now set the (optional) Kubernetes configuration up, and for this it's simple, choosing a CNI (which defaults to Cilium if unselected anyway) and enabling SELinux:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cat << EOF > kubernetes/config/server.yaml\ncni: cilium\nselinux: true\nEOF\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now let's ensure that the NVIDIA RuntimeClass is created on the Kubernetes cluster:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"cat << EOF > kubernetes/manifests/nvidia-runtime-class.yaml\napiVersion: node.k8s.io/v1\nkind: RuntimeClass\nmetadata:\n  name: nvidia\nhandler: nvidia\nEOF\n"})}),"\n",(0,t.jsx)(n.p,{children:"We'll leverage the built-in Helm Controller to deploy the NVIDIA Device Plugin through Kubernetes itself; we provide the configuration, and it will be applied at boot:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:'cat << EOF > kubernetes/helm/nvidia-device-plugin.yaml\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: nvidia-device-plugin\n---\napiVersion: helm.cattle.io/v1\nkind: HelmChart\nmetadata:\n  name: nvidia-device-plugin\n  namespace: nvidia-device-plugin\nspec:\n  repo: https://nvidia.github.io/k8s-device-plugin\n  chart: nvidia-device-plugin\n  targetNamespace: nvidia-device-plugin\n  version: v0.14.5\n  set:\n    runtimeClassName: nvidia\n    allowDefaultNamespace: "true"\nEOF\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["NOTE: We use ",(0,t.jsx)(n.code,{children:'allowDefaultNamespace: "true"'})," in the above example only for initial template parsing during the image build process so we can identify the required images that need to be pulled into the Embedded Registry for air-gapping purposes (default behaviour for Edge). When the template is deployed at boot time, the ",(0,t.jsx)(n.code,{children:"targetNamespace"})," will be used instead."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"We'll need to grab the NVIDIA Container Toolkit RPM public key before proceeding:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"mkdir -p rpms/gpg-keys\ncurl -o rpms/gpg-keys/nvidia-container-toolkit.key https://nvidia.github.io/libnvidia-container/gpgkey\n"})}),"\n",(0,t.jsxs)(n.p,{children:["All of the required artefacts, including Kubernetes binary, container images, Helm charts (and any referenced images) will be automatically air-gapped, meaning that the systems at deploy time should require no internet connectivity by default. Now you need only grab the SLE Micro ISO from the ",(0,t.jsx)(n.a,{href:"https://www.suse.com/download/sle-micro/",children:"SUSE Downloads Page"})," (and place it in the ",(0,t.jsx)(n.code,{children:"base-images"})," directory), and you can call the Edge Image Builder tool to generate the ISO for you. To complete the example, here's the command that was used to build the image:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"podman run --rm --privileged -it -v /path/to/eib-files/:/eib eib:dev build \\\n  -config-file eib-config-iso.yaml -config-dir /eib -build-dir /eib/_build\n"})}),"\n",(0,t.jsxs)(n.p,{children:["For further instructions, please see the ",(0,t.jsx)(n.a,{href:"https://github.com/suse-edge/edge-image-builder/blob/main/docs/building-images.md",children:"documentation"})," for Edge Image Builder."]}),"\n",(0,t.jsx)(n.h2,{id:"resolving-issues",children:"Resolving issues"}),"\n",(0,t.jsx)(n.h3,{id:"nvidia-smi-does-not-find-the-gpu",children:"nvidia-smi does not find the GPU"}),"\n",(0,t.jsxs)(n.p,{children:["Check the kernel messages using ",(0,t.jsx)(n.code,{children:"dmesg"}),". In case this indicates that it fails to allocate ",(0,t.jsx)(n.code,{children:"NvKMSKapDevice"}),", then apply the unsupported GPU workaround:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"sed -i '/NVreg_OpenRmEnableUnsupportedGpus/s/^#//g' /etc/modprobe.d/50-nvidia-default.conf\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"NOTE"}),": You will need to reload the kernel module, or reboot, if you change the kernel module configuration in the above step for it to take effect."]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},4319:(e,n,i)=>{i.d(n,{Z:()=>t});const t=i.p+"assets/images/scc-packages-nvidia-3a6544420991fb6136d126145a9d7b2a.png"},1151:(e,n,i)=>{i.d(n,{Z:()=>r,a:()=>o});var t=i(7294);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);