[{"title":"Overview","type":0,"sectionRef":"#","url":"/docusaurus-test/","content":"Overview Welcome to the SUSE Edge Engineering docs site.","keywords":""},{"title":"Rancher portfolio disambiguation","type":0,"sectionRef":"#","url":"/docusaurus-test/misc/rancher-disambiguation","content":"","keywords":""},{"title":"TL;DR​","type":1,"pageTitle":"Rancher portfolio disambiguation","url":"/docusaurus-test/misc/rancher-disambiguation#tldr","content":"RKE1, RKE2 and K3s are flavours of Kubernetes, Rancher Manager can be used to manage and provision different deployments of Kubernetes itself with a primary focus on RKE1/RKE2, Fleet can watch Git Repositories, detect changes and tell Kubernetes what it needs to be running, Elemental considers a specific approach to provisioning Kubernetes in Edge scenarios where the provisioning can be preloaded at the OS level for Rancher Manager to control later "},{"title":"Rancher​","type":1,"pageTitle":"Rancher portfolio disambiguation","url":"/docusaurus-test/misc/rancher-disambiguation#rancher","content":"Rancher (or Rancher Manager) is a multi cluster management solution for provisioning, managing and accessing multiple downstream kubernetes clusters. To provision new clusters Rancher can interact with different infrastructure and virtualization tools (vSphere/AWS etc) as an api client, request VMs and networks and setup a kubernetes cluster inside of those, it also works with bare metal machines by generating an join command you an run each time. "},{"title":"Fleet​","type":1,"pageTitle":"Rancher portfolio disambiguation","url":"/docusaurus-test/misc/rancher-disambiguation#fleet","content":"Fleet is usually a component of Rancher (although it can be used independently) that allows you to use a GitOps workflow for multi-cluster (i.e it allows you to define your git repositories and the clusters they should apply to at the management cluster level). "},{"title":"Elemental​","type":1,"pageTitle":"Rancher portfolio disambiguation","url":"/docusaurus-test/misc/rancher-disambiguation#elemental","content":"Elemental is a way to automatically deploy/register new clusters and manage the OS of their node, you can define clusters and their nodes on the management cluster then generate an OS installer image, when booting your node from that image it will install the node, register it to the manager and configure it for its role in the local cluster. This is the SUSE/Rancher way of doing zero touch provisioning. Elemental takes a different view of cluster provisioning focused on Edge deployments, typically Rancher services datacentre deployments of Kubernetes with enterprise servers etc; in an Edge scenario e.g. factory or cruise ship theres no guarantee of access for Rancher to contact and provision a cluster directly (i.e. limited bandwidth, firewalls etc) - Elemental instead is used to preload an operating system with all the information needed to set the cluster up, you can install that into the servers that you want to cluster and then it will reach back to Rancher to be under management at that point "},{"title":"Kubernetes​","type":1,"pageTitle":"Rancher portfolio disambiguation","url":"/docusaurus-test/misc/rancher-disambiguation#kubernetes","content":"Kubernetes as a standard and core technology is really a cross industry effort like Linux and has become core to DevOps as a cultural movement - as it enables defining and deploying your infrastructure as code and with lots of automation for extensive business continuity and high availability Kubernetes is a receptacle though - it runs what you tell it to run, usually people use automation to tell it what to do and this requires some kind of application to detect application configuration and apply it to Kubernetes - usually this is fulfilled through developer pipelines (CI/CD) where things are deployed as they are developed "},{"title":"Kubernetes distributions​","type":1,"pageTitle":"Rancher portfolio disambiguation","url":"/docusaurus-test/misc/rancher-disambiguation#kubernetes-distributions","content":"Kubernetes Distributions, like Linux OSes, come in different flavours, RKE and RKE2 are two different flavours of Kubernetes in this manner; but like Ubuntu vs SUSE do for an OS they are ultimately just packaging an implementation of Kubernetes. Other examples include EKS,AKS and GKE which are flavours produced by AWS, Azure and GCP respectively. When we say a kubernetes cluster we mean a specific instance of a distribution installed on servers that are managed as a group (each server being a node in the cluster) "},{"title":"K3Ss​","type":1,"pageTitle":"Rancher portfolio disambiguation","url":"/docusaurus-test/misc/rancher-disambiguation#k3ss","content":"K3s is a fully compliant and lightweight Kubernetes distribution focused on Edge, IoT, ARM or just for situations where a PhD in K8s clusterology is infeasible "},{"title":"RKE (or RKE1)​","type":1,"pageTitle":"Rancher portfolio disambiguation","url":"/docusaurus-test/misc/rancher-disambiguation#rke-or-rke1","content":"Rancher Kubernetes Engine is a Kubernetes distribution that uses an older architecture and relies on Docker Engine to run containers "},{"title":"RKE2​","type":1,"pageTitle":"Rancher portfolio disambiguation","url":"/docusaurus-test/misc/rancher-disambiguation#rke2","content":"RKE2 also known as RKE Government, is Rancher's next-generation Kubernetes distribution that uses a newer architecture based on ContainerD. RKE2 combines the best-of-both-worlds from the 1.x version of RKE (hereafter referred to as RKE1) and K3s. From K3s, it inherits the usability, ease-of-operations, and deployment model. From RKE1, it inherits close alignment with upstream Kubernetes. In places K3s has diverged from upstream Kubernetes in order to optimize for edge deployments, but RKE1 and RKE2 can stay closely aligned with upstream. "},{"title":"Rancher vs K3s vs RKE​","type":1,"pageTitle":"Rancher portfolio disambiguation","url":"/docusaurus-test/misc/rancher-disambiguation#rancher-vs-k3s-vs-rke","content":"You don’t need Rancher to set up K3s or RKE1 or RKE2 on their own it just makes the whole process easier. Rancher runs as a Management Interface that can interact with running clusters and also provision new clusters - as well as manage authentication to the downstream clusters, and it can also do other things like interact with applications that kubernetes is orchestrating and provides monitoring tools "},{"title":"Intro","type":0,"sectionRef":"#","url":"/docusaurus-test/quickstart/slemicro-utm-aarch64","content":"","keywords":""},{"title":"OSX Virtualization​","type":1,"pageTitle":"Intro","url":"/docusaurus-test/quickstart/slemicro-utm-aarch64#osx-virtualization","content":"Virtualization of Linux hosts on OSX can be achieved with various tools. There are commercial products such as VMWare Fusion or Parallels Desktop as well as open-source projects such as VirtualBox, UTM or Lima. UTM is an OSX application that uses QEMU under the hood and offers a GUI to manage the VM lifecycle. It supports Apple silicon CPUs, and it can use native OSX virtualization (Virtualization.framework) as well. It also has a scripting interface via Apple Script to automate some processes and a proper CLI (utmctl) is on the works. Lima is based on QEMU (experimental support for Virtualization.framework) as well and it launches Linux virtual machines with automatic file sharing and port forwarding (like WSL2), and containerd. Lima is expected to be used on macOS hosts, but can be used on Linux hosts as well. Lima has a proper CLI tool (limactl) and the best part is VMs can be defined in yaml files, so you can even deploy K8s clusters with just a single command (see https://github.com/lima-vm/lima/blob/master/examples/k8s.yaml) NOTE: Rancher desktop is based on Lima However, Lima doesn't support SLE Micro (yet) as Lima customizes the VM at boot to install some packages and services and SLE Micro uses a different approach to those things (for example as it is immutable, it requires installing packages using ignition/combustion) "},{"title":"SLE Micro installation automation: ISO vs Image​","type":1,"pageTitle":"Intro","url":"/docusaurus-test/quickstart/slemicro-utm-aarch64#sle-micro-installation-automation-iso-vs-image","content":"SLE Micro can be installed traditionally using an ISO file that boots once and using click-ops you can customize it as you wish (see https://documentation.suse.com/sle-micro/5.3/single-html/SLE-Micro-deployment/#cha-install) but that won't be useful. ISO installation can be customized using boot parameters (see https://documentation.suse.com/sle-micro/5.3/single-html/SLE-Micro-deployment/#sec-boot-parameters-list) but those don't cover all the options. However, ISO based installation supports using AutoYaST (see https://documentation.suse.com/sle-micro/5.3/single-html/SLE-Micro-autoyast/) to automate the installation process. SLE Micro can be also deployed using pre-built images. Currently, there are two types of images available: raw disk images and selfinstall ISOs. SLE Micro raw images are delivered for the AMD64/Intel 64 architecture, IBM Z ZSeries and also AArch64, however the selfinstall images are currently delivered only for the AMD64/Intel 64 architecture. The pre-built images (both selfinstall ISOs and raw disk images) are intended to be configured on the first boot by using either Ignition or Combustion. To summarize, the two ways as of today to deploy SLE Micro on Aarch64 on an automated fashion would be using the ISO + AutoYaST or raw images + Ignition/Combustion. "},{"title":"Ignition vs Butane vs Combustion​","type":1,"pageTitle":"Intro","url":"/docusaurus-test/quickstart/slemicro-utm-aarch64#ignition-vs-butane-vs-combustion","content":"Ignition is a provisioning tool that enables you to configure a system according to your specification on the first boot. When the system is booted for the first time, Ignition is loaded as part of an initramfs and searches for a configuration file within a specific directory (on a USB flash disk, or you can provide a URL). All changes are performed before the kernel switches from the temporal file system to the real root file system (before the switch_root command is issued). Ignition uses a configuration file in the JSON format. The file is called config.ign. SLE Micro supportsIgnition config spec 3.3.0(seehttps://documentation.suse.com/sle-micro/5.3/single-html/SLE-Micro-deployment/#sec-ignition-configurationfor more information). Ignition files can be complex to generate manually (specially for the file permissions syntax in hex or multiline things) so you can useopensuse.github.io/fuel-ignitionto help you generate a basic one. Butane is a more human readable (and writable) configuration syntax based on yaml that can be translated to Ignition easily with the butane CLI as Butane is not consumable by Ignition. Combustion is a dracut module that enables you to configure your system on its first boot. Combustion reads a provided file called script and executes commands in it and thus performs changes to the file system. You can use Combustion to change the default partitions, set users\\' passwords, create files, install packages, etc. The Combustion dracut module is invoked after the ignition.firstboot argument is passed to the kernel command line. Combustion then reads the configuration from script. Combustion tries to configure the network, if the network flag has been found in script. After /sysroot is mounted, Combustion tries to activate all mount points in /etc/fstab and then call transactional-update to apply other changes (like setting root password or installing packages). See https://documentation.suse.com/sle-micro/5.3/single-html/SLE-Micro-deployment/#sec-combustion-scriptfor more information. "},{"title":"Ignition/Combustion and UTM​","type":1,"pageTitle":"Intro","url":"/docusaurus-test/quickstart/slemicro-utm-aarch64#ignitioncombustion-and-utm","content":"Ignition and Combustion are intended to automate the deployment of SLE Micro systems. To use them with UTM there are a couple of alternatives: Use the QEMU fw_cfg flag as -fw_cfg name=opt/org.opensuse.combustion/script,file=/var/combustion-scriptfor combustion or -fw_cfg name=opt/com.coreos/config,file=PATH_TO_config.ign for ignition Create a raw disk or ISO file to host the Ignition or Combustion (or both) files. For Ignition, the configuration file config.ign must reside in theignition subdirectory on the configuration media labeled ignition. The directory structure must look as follows: &lt;root directory&gt; └── ignition └── config.ign  For Combustion, the configuration device needs to be named combustion, a specific directory structure in that configuration medium needs to be created and include a configuration file named script. In the root directory of the configuration medium, create a directory calledcombustion and place the script into this directory along with other files---SSH key, configuration files, etc. The directory structure then should look as follows: &lt;root directory&gt; └── combustion └── script └── other files  Combustion can be used along with Ignition. If you intend to do so, label your configuration medium ignition and include the ignitiondirectory with the config.ign to your directory structure as shown below: &lt;root directory&gt; └── combustion └── script └── other files └── ignition └── config.ign  In this scenario, Ignition runs before Combustion. Image-based process step by step NOTE: There is a helper script that automates all the steps included herehttps://github.com/suse-edge/misc/blob/main/slemicro/create_vm.sh "},{"title":"Prerequisites​","type":1,"pageTitle":"Intro","url":"/docusaurus-test/quickstart/slemicro-utm-aarch64#prerequisites","content":"SLE Micro raw image Download the raw image file from the SUSE website at https://www.suse.com/download/sle-micro/ Select ARM architectureLook for the raw file (I.e.- SLE-Micro.aarch64-5.3.0-Default-GM.raw.xz) NOTE: You need to have a valid user on the SUSE site to be able to download the file. Access to https://scc.suse.com/ to generate a registration code Butane, qemu-img and cdrtools installed (using brew for example) brew install butane cdrtools qemu-img UTM installed (using brew for example) brew install --cask utm  Note: If using the previous script, it is required to install UTM 4.2.2 at least as it includes the proper support for the automation. "},{"title":"Image preparation​","type":1,"pageTitle":"Intro","url":"/docusaurus-test/quickstart/slemicro-utm-aarch64#image-preparation","content":"Uncompress the SLE Micro image xz -d ~/Downloads/SLE-Micro.aarch64-5.3.0-Default-GM.raw.xz Move the file to a proper location and rename it to fit the VM hostname cp ~/Downloads/SLE-Micro.aarch64-5.3.0-Default-GM.raw ~/VMs/slemicro.raw Resize the image file. In this example, to 30G qemu-img resize -f raw ~/VMs/slemicro.raw 30G &gt; /dev/null  "},{"title":"Ignition & Combustion files​","type":1,"pageTitle":"Intro","url":"/docusaurus-test/quickstart/slemicro-utm-aarch64#ignition--combustion-files","content":"To automate the installation, we will leverage Butane, Ignition and Combustion as explained before: Create a temporary folder to store the assets TMPDIR=$(mktemp -d) Create the required folders for ignition and combustion mkdir -p ${TMPDIR}/{combustion,ignition} Create a config.fcc butane config file as required. See the following example to set a root password for the root user, and to configure the hostname to be &quot;slemicro&quot;' cat &lt;&lt; EOF &gt; ${TMPDIR}/config.fcc variant: fcos version: 1.4.0 storage: files: - path: /etc/hostname mode: 0644 overwrite: true contents: inline: &quot;slemicro&quot; passwd: users: - name: root password_hash: &quot;$y$j9T$/t4THH10B7esLiIVBROsE.$G1lyxfy/MoFVOrfXSnWAUq70Tf3mjfZBIe18koGOuXB&quot; EOF Create a script combustion file as required. See the following example to register the SLE Micro instance to SUSE's SCC (use your own email/regcode) and to create a /etc/issue.d/combustion file cat &lt;&lt; EOF &gt; ${TMPDIR}/combustion/script #!/bin/bash # combustion: network # Redirect output to the console exec &gt; &gt;(exec tee -a /dev/tty0) 2&gt;&amp;1 # Set hostname at combustion phase for SUSEConnect hostname slemicro # Registration if ! which SUSEConnect &gt; /dev/null 2&gt;&amp;1; then zypper --non-interactive install suseconnect-ng fi SUSEConnect --email foobar@suse.com --url https://scc.suse.com --regcode YOURCODE # Leave a marker echo &quot;Configured with combustion&quot; &gt; /etc/issue.d/combustion EOF Convert the butane config to ignition butane -p -o ${TMPDIR}/ignition/config.ign ${TMPDIR}/config.fcc Create an ISO file. It is requried for both ignition and combustion to work that the ISO is labeled as ignition (hence the -V parameter) mkisofs -full-iso9660-filenames -o ignition-and-combustion.iso -V ignition ${TMPDIR} Optional: Remove the temporary folder rm -Rf ${TMPDIR}  "},{"title":"VM Creation​","type":1,"pageTitle":"Intro","url":"/docusaurus-test/quickstart/slemicro-utm-aarch64#vm-creation","content":"Now it is time to finally use UTM to boot the VM  Create a New Virtual Machine using Virtualization  Select &quot;Other&quot;  Enable the &quot;Skip ISO boot&quot; option as we will use the raw disk directly  Select the required CPU/RAM:  Accept the storage size as it is, it will be deleted before booting it  Skip the Shared Directory  Edit the VM name and enable the &quot;Open VM Settings&quot; toggle to customize it further:  Delete the VirtIO Drive  Add a new Device and select &quot;Import&quot;  Select the raw image file (~/VMs/slemicro.raw in this case)  Repeat the last two steps to add the ignition-and-combustion.iso file  Configure the ISO as Read Only and &quot;CD/DVD (ISO) Image&quot;  Finally, boot the VM. After a couple of seconds, the VM will boot up and will configure itself using the ignition and combustion scripts, including registering itself to SCC   NOTE: In case the VM doesn't get network connectivity, tryhttps://github.com/utmapp/UTM/discussions/3530#discussioncomment-5072113 ISO Process (TBD) Download the ISO fileCreate a new VM on UTM using the ISO fileCreate the autoyast answer fileUse the AutoYaST boot parameter to map to the answer fileBoot the VMProfit! "}]